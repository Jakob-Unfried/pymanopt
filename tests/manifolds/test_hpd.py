import numpy as np
import pytest
from numpy import linalg as la
from numpy import random as rnd
from numpy import testing as np_testing
from scipy.linalg import eigvalsh

from pymanopt.manifolds import (
    HermitianPositiveDefinite,
    SpecialHermitianPositiveDefinite,
)
from pymanopt.tools.multi import multiherm, multitransp


class TestSingleHermitianPositiveDefiniteManifold:
    @pytest.fixture(autouse=True)
    def setUp(self):
        self.n = n = 15
        self.man = HermitianPositiveDefinite(n)

    def test_dim(self):
        man = self.man
        n = self.n
        np_testing.assert_equal(man.dim, n * (n + 1))

    def test_random_point(self):
        # Just test that random_point returns a point on the manifold and two
        # different matrices generated by random_point aren't too close together
        n = self.n
        man = self.man
        x = man.random_point()

        assert np.shape(x) == (n, n)
        assert x.dtype == complex

        # Check symmetry
        np_testing.assert_allclose(x, multiherm(x))

        # Check positivity of eigenvalues
        w = la.eigvalsh(x)
        assert (w > [0]).all()

    def test_random_tangent_vector(self):
        # Just test that randvec returns an element of the tangent space
        # with norm 1 and that two randvecs are different.
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        v = man.random_tangent_vector(x)
        np_testing.assert_allclose(multiherm(u), u)
        np_testing.assert_almost_equal(1, man.norm(x, u))
        assert la.norm(u - v) > 1e-3

    def test_inner_product(self):
        man = self.man
        x = man.random_point()
        a = man.random_tangent_vector(x)
        b = man.random_tangent_vector(x)
        np.testing.assert_almost_equal(
            np.real(np.trace(a @ b)), man.inner_product(x, x @ a, x @ b)
        )
        assert man.inner_product(x, a, b).dtype == float

        x_inv = np.linalg.inv(x)
        inner = np.real(np.trace(x_inv @ a @ x_inv @ b))
        np.testing.assert_almost_equal(inner, man.inner_product(x, a, b))

    def test_norm(self):
        man = self.man
        u = man.random_tangent_vector(np.eye(self.n))
        np.testing.assert_almost_equal(man.norm(np.eye(self.n), u), la.norm(u))

        x = man.random_point()
        u = man.random_tangent_vector(x)
        np.testing.assert_almost_equal(
            np.sqrt(man.inner_product(x, u, u)), man.norm(x, u)
        )

    def test_projection(self):
        man = self.man
        x = man.random_point()
        a = rnd.randn(self.n, self.n) + 1j * rnd.randn(self.n, self.n)
        np.testing.assert_allclose(man.projection(x, a), multiherm(a))
        np.testing.assert_allclose(
            man.projection(x, a), man.projection(x, man.projection(x, a))
        )

    def test_euclidean_to_riemannian_gradient(self):
        man = self.man
        x = man.random_point()
        u = rnd.randn(self.n, self.n) + 1j * rnd.randn(self.n, self.n)
        np.testing.assert_allclose(
            man.euclidean_to_riemannian_gradient(x, u), x @ multiherm(u) @ x
        )

    def test_exp(self):
        # exp(x, u) = x + u.
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        e = man.exp(x, u)

        # Check symmetry
        np_testing.assert_allclose(e, multiherm(e))

        # Check positivity of eigenvalues
        w = la.eigvalsh(e)
        assert (w > [0]).all()

        u = u * 1e-6
        np_testing.assert_allclose(man.exp(x, u), x + u)

    def test_exp_log_inverse(self):
        man = self.man
        x = man.random_point()
        y = man.random_point()
        u = man.log(x, y)
        np_testing.assert_allclose(man.exp(x, u), y)

    def test_log_exp_inverse(self):
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        y = man.exp(x, u)
        np_testing.assert_allclose(man.log(x, y), u)

    def test_transp(self):
        man = self.man
        x = man.random_point()
        y = man.random_point()
        u = man.random_tangent_vector(x)
        t_u = man.transp(x, y, u)
        np_testing.assert_allclose(t_u, man.projection(y, t_u))

    def test_dist(self):
        man = self.man
        x = man.random_point()
        y = man.random_point()

        # Test separability
        np_testing.assert_almost_equal(man.dist(x, x), 0.0)

        # Test symmetry
        np_testing.assert_almost_equal(man.dist(x, y), man.dist(y, x))

        # Test alternative implementation
        # from Eq 6.14 of "Positive definite matrices"
        d = np.sqrt((np.log(np.real(eigvalsh(x, y))) ** 2).sum())
        np_testing.assert_almost_equal(man.dist(x, y), d)

        # check that dist is consistent with log
        np_testing.assert_almost_equal(
            man.dist(x, y), man.norm(x, man.log(x, y))
        )


class TestMultiHermitianPositiveDefiniteManifold:
    @pytest.fixture(autouse=True)
    def setUp(self):
        self.n = n = 10
        self.k = k = 3
        self.man = HermitianPositiveDefinite(n, k)

    def test_dim(self):
        man = self.man
        n = self.n
        k = self.k
        np_testing.assert_equal(man.dim, k * n * (n + 1))

    def test_random_point(self):
        # Just test that rand returns a point on the manifold and two
        # different matrices generated by rand aren't too close together
        k = self.k
        n = self.n
        man = self.man
        x = man.random_point()

        assert np.shape(x) == (k, n, n)
        assert x.dtype == complex

        # Check symmetry
        np_testing.assert_allclose(x, multiherm(x))

        # Check positivity of eigenvalues
        w = la.eigvalsh(x)
        assert (w > [[0]]).all()

    def test_random_tangent_vector(self):
        # Just test that randvec returns an element of the tangent space
        # with norm 1 and that two randvecs are different.
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        v = man.random_tangent_vector(x)
        np_testing.assert_allclose(multiherm(u), u)
        np_testing.assert_almost_equal(1, man.norm(x, u))
        assert la.norm(u - v) > 1e-3

    def test_inner_product(self):
        man = self.man
        x = man.random_point()
        a = man.random_tangent_vector(x)
        b = man.random_tangent_vector(x)
        # b is not symmetric, it is Hermitian
        np.testing.assert_almost_equal(
            np.tensordot(a, multitransp(b), axes=a.ndim),
            man.inner_product(x, x @ a, x @ b),
        )
        assert man.inner_product(x, a, b).dtype == float

    def test_norm(self):
        man = self.man
        Id = np.array(self.k * [np.eye(self.n)])
        u = man.random_tangent_vector(Id)
        np.testing.assert_almost_equal(man.norm(Id, u), la.norm(u))

        x = man.random_point()
        u = man.random_tangent_vector(x)
        np.testing.assert_almost_equal(
            np.sqrt(man.inner_product(x, u, u)), man.norm(x, u)
        )

    def test_projection(self):
        man = self.man
        x = man.random_point()
        a = rnd.randn(self.k, self.n, self.n)
        +1j * rnd.randn(self.k, self.n, self.n)
        np.testing.assert_allclose(man.projection(x, a), multiherm(a))
        np.testing.assert_allclose(
            man.projection(x, a), man.projection(x, man.projection(x, a))
        )

    def test_euclidean_to_riemannian_gradient(self):
        man = self.man
        x = man.random_point()
        u = rnd.randn(self.k, self.n, self.n)
        +1j * rnd.randn(self.k, self.n, self.n)
        np.testing.assert_allclose(
            man.euclidean_to_riemannian_gradient(x, u), x @ multiherm(u) @ x
        )

    def test_exp(self):
        # Test against manopt implementation, test that for small vectors
        # exp(x, u) = x + u.
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        e = man.exp(x, u)

        # Check symmetry
        np_testing.assert_allclose(e, multiherm(e))

        # Check positivity of eigenvalues
        w = la.eigvalsh(e)
        assert (w > [[0]]).all()

        u = u * 1e-6
        np_testing.assert_allclose(man.exp(x, u), x + u)

    def test_retraction(self):
        # Check that result is on manifold and for small vectors
        # retraction(x, u) = x + u.
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        y = man.retraction(x, u)

        assert np.shape(y) == (self.k, self.n, self.n)
        # Check symmetry
        np_testing.assert_allclose(y, multiherm(y))

        # Check positivity of eigenvalues
        w = la.eigvalsh(y)
        assert (w > [[0]]).all()

        u = u * 1e-6
        np_testing.assert_allclose(man.retraction(x, u), x + u)

    def test_exp_log_inverse(self):
        man = self.man
        x = man.random_point()
        y = man.random_point()
        u = man.log(x, y)
        np_testing.assert_allclose(man.exp(x, u), y)

    def test_log_exp_inverse(self):
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        y = man.exp(x, u)
        np_testing.assert_allclose(man.log(x, y), u)

    def test_transp(self):
        man = self.man
        x = man.random_point()
        y = man.random_point()
        u = man.random_tangent_vector(x)
        t_u = man.transp(x, y, u)
        np_testing.assert_allclose(t_u, man.projection(y, t_u))

    def test_dist(self):
        man = self.man
        x = man.random_point()
        y = man.random_point()

        # Test separability
        np_testing.assert_almost_equal(man.dist(x, x), 0.0)

        # Test symmetry
        np_testing.assert_almost_equal(man.dist(x, y), man.dist(y, x))

        # check that dist is consistent with log
        np_testing.assert_almost_equal(
            man.dist(x, y), man.norm(x, man.log(x, y))
        )


class TestSingleSpecialHermitianPositiveDefiniteManifold:
    @pytest.fixture(autouse=True)
    def setUp(self):
        self.n = n = 10
        self.k = k = 1
        self.man = SpecialHermitianPositiveDefinite(n, k)

    def test_dim(self):
        man = self.man
        n = self.n
        np_testing.assert_equal(man.dim, n * (n + 1) - 1)

    def test_random_point(self):
        # Just test that rand returns a point on the manifold and two
        # different matrices generated by rand aren't too close together
        n = self.n
        man = self.man
        x = man.random_point()
        y = man.random_point()

        assert np.shape(x) == (n, n)
        assert x.dtype == complex

        # Check symmetry
        np_testing.assert_allclose(x, multiherm(x))

        # Check positivity of eigenvalues
        w = la.eigvalsh(x)
        assert (w > [[0]]).all()

        # Check unit determinant
        d = np.real(la.det(x))
        np_testing.assert_allclose(d, 1)

        # Check randomness
        assert la.norm(x - y) > 1e-3

    def test_random_tangent_vector(self):
        # Just test that randvec returns an element of the tangent space
        # with norm 1 and that two randvecs are different.
        man = self.man
        n = self.n
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        v = man.random_tangent_vector(x)

        assert np.shape(x) == (n, n)
        assert x.dtype == complex

        np_testing.assert_allclose(multiherm(u), u)

        t = np.real(np.trace(la.solve(x, u)))
        np_testing.assert_almost_equal(t, 0)

        np_testing.assert_almost_equal(1, man.norm(x, u))

        assert la.norm(u - v) > 1e-3

    def test_inner_product(self):
        man = self.man
        x = man.random_point()
        a = man.random_tangent_vector(x)
        b = man.random_tangent_vector(x)
        # b is not symmetric, it is Hermitian
        np.testing.assert_almost_equal(
            np.tensordot(a, multitransp(b), axes=a.ndim),
            man.inner_product(x, x @ a, x @ b),
        )
        assert man.inner_product(x, a, b).dtype == float

    def test_norm(self):
        man = self.man
        Id = np.eye(self.n)
        u = man.random_tangent_vector(Id)
        np.testing.assert_almost_equal(man.norm(Id, u), la.norm(u))

        x = man.random_point()
        u = man.random_tangent_vector(x)
        np.testing.assert_almost_equal(
            np.sqrt(man.inner_product(x, u, u)), man.norm(x, u)
        )

    def test_projection(self):
        man = self.man
        x = man.random_point()
        a = rnd.randn(self.n, self.n)
        +1j * rnd.randn(self.n, self.n)
        p = man.projection(x, a)

        assert np.shape(p) == (self.n, self.n)

        np.testing.assert_allclose(p, multiherm(p))

        t = np.real(np.trace(la.solve(x, p)))
        np_testing.assert_almost_equal(t, 0)

        np.testing.assert_allclose(p, man.projection(x, p))

    def test_exp(self):
        # Test against manopt implementation, test that for small vectors
        # exp(x, u) = x + u.
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        e = man.exp(x, u)
        assert np.shape(e) == (self.n, self.n)

        # Check symmetry
        np_testing.assert_allclose(e, multiherm(e))

        # Check positivity of eigenvalues
        w = la.eigvalsh(e)
        assert (w > [[0]]).all()

        # Check unit determinant
        d = la.det(e)
        np_testing.assert_allclose(d, 1)

        u = u * 1e-6
        np_testing.assert_allclose(man.exp(x, u), x + u)

    def test_retraction(self):
        # Check that result is on manifold and for small vectors
        # retraction(x, u) = x + u.
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        y = man.retraction(x, u)

        assert np.shape(y) == (self.n, self.n)
        # Check symmetry
        np_testing.assert_allclose(y, multiherm(y))

        # Check positivity of eigenvalues
        w = la.eigvalsh(y)
        assert (w > [[0]]).all()

        # Check unit determinant
        d = la.det(y)
        np_testing.assert_allclose(d, 1)

        u = u * 1e-6
        np_testing.assert_allclose(man.retraction(x, u), x + u)

    def test_exp_log_inverse(self):
        man = self.man
        x = man.random_point()
        y = man.random_point()
        u = man.log(x, y)
        np_testing.assert_allclose(man.exp(x, u), y)

    def test_log_exp_inverse(self):
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        y = man.exp(x, u)
        np_testing.assert_allclose(man.log(x, y), u)

    def test_transp(self):
        man = self.man
        x = man.random_point()
        y = man.random_point()
        u = man.random_tangent_vector(x)
        transp_u = man.transp(x, y, u)
        np_testing.assert_allclose(transp_u, self.man.projection(y, transp_u))

    def test_dist(self):
        man = self.man
        x = man.random_point()
        y = man.random_point()

        # Test separability
        np_testing.assert_almost_equal(man.dist(x, x), 0.0)

        # Test symmetry
        np_testing.assert_almost_equal(man.dist(x, y), man.dist(y, x))

        # check that dist is consistent with log
        np_testing.assert_almost_equal(
            man.dist(x, y), man.norm(x, man.log(x, y))
        )


class TestMultiSpecialHermitianPositiveDefiniteManifold:
    @pytest.fixture(autouse=True)
    def setUp(self):
        self.n = n = 10
        self.k = k = 3
        self.man = SpecialHermitianPositiveDefinite(n, k)

    def test_dim(self):
        man = self.man
        n = self.n
        k = self.k
        np_testing.assert_equal(man.dim, k * (n * (n + 1) - 1))

    def test_random_point(self):
        # Just test that rand returns a point on the manifold and two
        # different matrices generated by rand aren't too close together
        k = self.k
        n = self.n
        man = self.man
        x = man.random_point()
        y = man.random_point()

        assert np.shape(x) == (k, n, n)
        assert x.dtype == complex

        # Check symmetry
        np_testing.assert_allclose(x, multiherm(x))

        # Check positivity of eigenvalues
        w = la.eigvalsh(x)
        assert (w > [[0]]).all()

        # Check unit determinant
        d = np.real(la.det(x))
        np_testing.assert_allclose(d, 1)

        # Check randomness
        assert la.norm(x - y) > 1e-3

    def test_random_tangent_vector(self):
        # Just test that randvec returns an element of the tangent space
        # with norm 1 and that two randvecs are different.
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        v = man.random_tangent_vector(x)

        np_testing.assert_allclose(multiherm(u), u)

        t = np.empty(man._k, dtype=complex)
        temp = la.solve(x, u)
        for i in range(man._k):
            t[i] = np.real(np.trace(temp[i, :, :]))
        np_testing.assert_allclose(t, 0, atol=1e-7)

        np_testing.assert_almost_equal(1, man.norm(x, u))

        assert la.norm(u - v) > 1e-3

    def test_inner_product(self):
        man = self.man
        x = man.random_point()
        a = man.random_tangent_vector(x)
        b = man.random_tangent_vector(x)
        # b is not symmetric, it is Hermitian
        np.testing.assert_almost_equal(
            np.tensordot(a, multitransp(b), axes=a.ndim),
            man.inner_product(x, x @ a, x @ b),
        )
        assert man.inner_product(x, a, b).dtype == float

    def test_norm(self):
        man = self.man
        Id = np.array(self.k * [np.eye(self.n)])
        u = man.random_tangent_vector(Id)
        np.testing.assert_almost_equal(man.norm(Id, u), la.norm(u))

        x = man.random_point()
        u = man.random_tangent_vector(x)
        np.testing.assert_almost_equal(
            np.sqrt(man.inner_product(x, u, u)), man.norm(x, u)
        )

    def test_projection(self):
        man = self.man
        x = man.random_point()
        a = rnd.randn(self.k, self.n, self.n) + 1j * rnd.randn(
            self.k, self.n, self.n
        )
        p = man.projection(x, a)

        np.testing.assert_allclose(p, multiherm(p))

        t = np.ones(man._k, dtype=complex)
        temp = la.solve(x, p)
        for i in range(man._k):
            t[i] = np.real(np.trace(temp[i, :, :]))
        np_testing.assert_allclose(t, 0, atol=1e-7)

        np.testing.assert_allclose(p, man.projection(x, p))

    def test_exp(self):
        # Test against manopt implementation, test that for small vectors
        # exp(x, u) = x + u.
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        e = man.exp(x, u)

        # Check symmetry
        np_testing.assert_allclose(e, multiherm(e))

        # Check positivity of eigenvalues
        w = la.eigvalsh(e)
        assert (w > [[0]]).all()

        # Check unit determinant
        d = la.det(e)
        np_testing.assert_allclose(d, 1)

        u = u * 1e-6
        np_testing.assert_allclose(man.exp(x, u), x + u)

    def test_retraction(self):
        # Check that result is on manifold and for small vectors
        # retraction(x, u) = x + u.
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        y = man.retraction(x, u)

        assert np.shape(y) == (self.k, self.n, self.n)
        # Check symmetry
        np_testing.assert_allclose(y, multiherm(y))

        # Check positivity of eigenvalues
        w = la.eigvalsh(y)
        assert (w > [[0]]).all()

        # Check unit determinant
        d = la.det(y)
        np_testing.assert_allclose(d, 1)

        u = u * 1e-6
        np_testing.assert_allclose(man.retraction(x, u), x + u)

    def test_exp_log_inverse(self):
        man = self.man
        x = man.random_point()
        y = man.random_point()
        u = man.log(x, y)
        np_testing.assert_allclose(man.exp(x, u), y)

    def test_log_exp_inverse(self):
        man = self.man
        x = man.random_point()
        u = man.random_tangent_vector(x)
        y = man.exp(x, u)
        np_testing.assert_allclose(man.log(x, y), u)

    def test_transp(self):
        man = self.man
        x = man.random_point()
        y = man.random_point()
        u = man.random_tangent_vector(x)
        transp_u = man.transp(x, y, u)
        np_testing.assert_allclose(transp_u, self.man.projection(y, transp_u))

    def test_dist(self):
        man = self.man
        x = man.random_point()
        y = man.random_point()

        # Test separability
        np_testing.assert_almost_equal(man.dist(x, x), 0.0)

        # Test symmetry
        np_testing.assert_almost_equal(man.dist(x, y), man.dist(y, x))

        # check that dist is consistent with log
        np_testing.assert_almost_equal(
            man.dist(x, y), man.norm(x, man.log(x, y))
        )
